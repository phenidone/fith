
Notes from jonesforth
! store also +! -!
@ fetch
STATE immediate or compiling.  Part of the INTERPRET function, i.e REPL
LATEST ptr to ptr to newest word
HERE ptr to ptr to next free byte
S0 ptr to data stack
BASE io radix
R0 ptr to return stack
DOCOL ptr to interp
F_IMMED (run even in compile mode), F_HIDDEN (find will fail), F_LENMASK (not the flags) various flags of a word
>R and R> transfer data between data/return stacks
RSP@ RSP! get/set the return-stack pointer via data stack
RDROP drop from return stack
DSP@ DSP! get/set data stack pointer to/from data stack!

WORD read a word from STDIN into static buffer, leaves char* and len on stack
NUMBER parse an int in a buffer, e.g. as returned by WORD
FIND locate word-header given a word (char* / len) on stack
>CFA convert word-pointer into code-pointer (skip word header)
DFA skip the DOCOL header

CREATE makes a word-header
[ ] enter/leave compilation mode
, COMMA appends to HERE, i.e. appends to a compilation

COLON == WORD CREATE (LIT DOCOL) , LATEST @ HIDDEN ] EXIT
  gets the word, creates header, appends DOCOL, sets hidden flag, sets compile mode

SEMICOLON == (LIT EXIT) COMMA LATEST @ HIDDEN [ EXIT
  appends the exit instruction, clears hidden-flag, clears compile mode

IMMEDIATE toggle the immediate bit of the latest word
HIDDEN toggle the hidden bit of a word pointed to on the stack
HIDE == WORD FIND HIDDEN EXIT

' TICK push the codeword address of the following word.  Get word address, i.e. obtain function pointer.

BRANCH uses offset following the opcode
0BRANCH is conditional, also relative.

." LITSTRING pushes char* / len of literal string
TELL prints a string

QUIT the entry-point.  while(true) { clear return-stack; INTERPRET; }
INTERPRET the REPL.  Read a word, look it up.  if immed, run it.  check if number (push or LIT ,) etc.

SYSCALL calls to OS

KEY read char
EMIT print char
\ comment to EOL

INTERPRET seems to be:

is_lit=false
WORD FIND
if(found){
    if(word_is_immed){
        exec_word
        return
    }
}
else{
    NUMBER
    if(parse OK){
         is_lit=true;
    }
    else{
        dummy spit
    }
}

if(state = compiling){
     comma
     if(is_lit){
          comma number   
     }
}
else{
    if(is_lit)
        push
    else
        call
}

to add:

: 2DUP OVER OVER ;
: 2DROP DROP DROP ;
2SWAP
2OVER
2NIP
2TUCK
2ROT
: 2>R >R >R ;
: 2R> R> R> ;
: 2R@ 2R> 2DUP 2>R ;

unsigned comparisons
