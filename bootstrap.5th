
: OVER SWAP DUP -ROT ;
: TUCK SWAP OVER ;
: NIP SWAP DROP ;

: TRUE 1 ;
: FALSE 0 ;
: NOT 0 = ;

: SPACE 32 EMIT ;
: CR 10 EMIT ;

: CHAR WORD 1 + @ 0xFF & ;
: LITERAL IMMEDIATE ' LIT , , ;

: ';' [ CHAR ; ] LITERAL ;
: ':' [ CHAR : ] LITERAL ;
: '(' [ CHAR ( ] LITERAL ;
: ')' [ CHAR ) ] LITERAL ;
: '"' [ CHAR " ] LITERAL ;
: 'A' [ CHAR A ] LITERAL ;
: '0' [ CHAR 0 ] LITERAL ;
: '-' [ CHAR - ] LITERAL ;
: '.' [ CHAR . ] LITERAL ;

: [COMPILE] IMMEDIATE WORD FIND , ;
: RECURSE IMMEDIATE LATEST FIND , ;

: BEGIN IMMEDIATE
  HERE @C
;

: UNTIL IMMEDIATE
  HERE @C -
  ' JZ ,
  ,
;

: IF IMMEDIATE
  ' JZ ,
  HERE @C
  0 ,
;

: ENDIF IMMEDIATE
  DUP HERE @C
  SWAP - 1 +
  SWAP !C
;

: ELSE IMMEDIATE
  ' JMP ,
  HERE @C
  0 ,
  SWAP [COMPILE] ENDIF
;

: ( IMMEDIATE
  1
  BEGIN
    CHAR
    DUP '(' = IF
      SWAP 1 + SWAP
    ENDIF
    ')' = IF
      1 -
    ENDIF
    DUP NOT
  UNTIL
  DROP
;

( now we can have comments in parens )

( BEGIN body cond UNTIL
  implements do { body; } while(cond); )

( BEGIN cond WHILE body LOOP
  implements while(cond){ body }
  because BEGIN was compiled first, we already have the
  loop target address on the stack )

: WHILE IMMEDIATE
  ' JZ ,    ( compile conditional branch )
  HERE @C   ( target &offset )
  0 ,       ( offset=0 )
;

( end of a loop )
( target &off -- )
: LOOP IMMEDIATE
  HERE @C       ( target &offset &jmp )
  ' JMP ,       ( compile jmp )
  ROT SWAP -    ( &offset target-&jmp )
  ,             ( &offset )
  DUP HERE @C   ( &offset &offset endloop )
  SWAP - 1 +    ( &offset endloop-&offset+1 )
  SWAP !C       ( patch the while-condition )
;
